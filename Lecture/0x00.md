# HTML CSS

## 목차

1. 개요
2. HTML 기본 문법
3. CSS 기본 문법
4. CSS 속성

## 개요

웹 프론트앤드 개발의 **핵심 줄기**를 학습! <u> 중요도가 높은 내용</u>을 위주로 학습

-   난이도가 높고 중요도가 낮은 내용은 <u>가볍게 학습</u>하거나 <u>생략</u>

### 프론트엔드 개발

-   HTML, CSS, JS를 사용해 데이터를 그래픽 사용자 인터페이스 (GUI)로 변환하고, 그것으로 사용자와 상호 작용할 수 있도록 하는 것

```
백엔드 -> 프론트엔드 -> 사용자
```

### HTML (Hyper Text Markup Language)

-   페이지의 제목, 문단, 표, 이미지, 동영상 등 <u>웹의 구조</u>를 담당

### CSS (Cascading Style Sheets)

-   실제 화면에 표시되는 방법 (색상, 크기, 폰트, 레이아웃 등)을 지정해 콘텐츠를 꾸며주는 <u>시각적인 표현(정적)</u>을 담당

### JS (JavaScript)

-   콘텐츠를 바꾸고 움직이는 등 페이지를 동작시키는 <u>동적 처리</u>를 담당

```
https://heropy.blog
사용자 브라우저 -> 최초 요청 (request) -> 서버
서버 -> 최초 응답 (response) [HTML] -> 사용자 브라우저 -> 렌더링 (Rendering)
사용자 브라우저 -> 추가 요청 -> 서버
서버 -> 추가 응답 [CSS, JS, JPG] -> 사용자 브라우저
```

## HTML 기본 문법

### <시작(열린) 태그> </종료(닫힌) 태그>

### <태그>내용</태그>

```html
<h1>Hello HTML</h1>
```

```
<부모 요소>
    <자식 요소>내용</자식 요소>
</부모 요소>
```

### XHTML / HTML

-   <태그/>
    -   종료 태그 없이 사용 가능함

### <태그 속성="값">내용</태그>

### \<img/>

-   이미지를 삽입하는 요소

```html
<img src="이미지 경로" alt="이미지의 이름 (대체 텍스트/alternate text)" />
```

### \<input/>

-   사용자가 데이터를 입력하는 요소

```html
<input type="text" />
<!--일반 텍스트 입력 받음-->
<input type="checkbox" />
<!--체크 여부 입력 받음-->
```

## 글자와 상자

-   요소가 화면에 출력되는 특성, 크게 `2`가지로 구분
    -   인라인(Inline) 요소: 글자를 만들기 위한 요소들
    -   블록(Block) 요소: 상자(레이아웃)를 만들기 위한 요소들

### \<span>

-   대표적인 인라인 요소!
-   본질적으로 아무것도 나타내지 않는, 콘텐츠 영역을 설정하는 용도

```html
<span>Hello</span>
<span>World</span>
<!--
요소가 수평으로 쌓임
포한한 콘텐츠 크기만큼 자동으로 줄어듬 
-->
```

```html
<span style="width:100px;">Hello</span>
<span style="height:100px;">World</span>
<!--반응 없음-->
```

```html
<span style="width:100px;">Hello</span>
<span style="height:100px;">World</span>
<!--반응 없음-->
```

```html
<span style="margin: 20px 20px;">Hello</span
><!--요소의 외부 여백을 지정하는 css 속성-->
<span style="padding: 20px 20px;">World</span
><!--요소의 내부 여백을 지정하는 css 속성-->
```

-   인라인 요소 내에 블록 요소 불가능

```html
<span><div></div></span
><!--불가능-->
<span><span></span></span
><!--가능-->
```

### \<div>

-   대표적인 블록 요소!
-   본질적으로 아무것도 나타내지 않는, 콘텐츠 영역을 설정하는 용도

```html
<div>Hello</div>
<div>World</div>
<!--
요소가 수직으로 쌓임
부모 요소의 수평 크기만큼 자동으로 늘어남
포함한 콘텐츠 수직 크기만큼 자동으로 줄어듬
-->
```

```html
<div style="width:100px;">Hello</div>
<div style="height:40px;">World</div>
<!--블록 크기 사이즈 크기로 바뀜-->
```

```html
<div style="margin: 10px;">Hello</div>
<!--요소의 외부 여백을 지정하는 css 속성-->
<div style="padding: 10px;">World</div>
<!--요소의 내부 여백을 지정하는 css 속성-->
```

```html
<div><div></div></div>
<!--가능-->
<div><span></span></div>
<!--가능-->
```

## HTML

```html
<!DOCTYPE html>
<!--문서의 HTML 버전을 지정
DOCTYPE(DTD, Document Type Definition)은 마크업 언어에서 문서 형식을 정의하며,
웹브라우저가 어떤 HTML 버전의 해석 방식으로 페이지을 이해하면 되는지 알려주는 용도
HTML5가 현재 표준-->
<html>
	<!--문서의 전체 범위, html 문서가 어디에서 시작하고 끝나는지 알려주는 역할-->
	<head>
		<!--문서의 정보를 나타내는 범위
        웹 브라우저가 해석해야 할
        웹 페이지의 제목, 설명, 사용할 파일 윛, 스타일(CSS) 같은,
        웹 페이지의 보이지 않는 정보를 작성하는 범위-->
	</head>
	<body>
		<!--문서의 구조를 나타내는 범위
        사용자 화면을 통해 보여지는
        로고, 헤더, 푸터, 내비게이션, 메뉴, 버튼, 이미지 같은,
        웹 페이지의 보여지는 구조를 작성하는 범위-->
	</body>
</html>
```

### xHTML

```html
<!DOCTYPE html PUBLIC "//W3C//DTD XHTML 1.0 Trans...">
```

```html
<head>
	<meta charset="UTF-8" />
	<meta name="author" content="HEROPY" />
	<meta name="viewport" content="width=device-width, initial-scale=..." />
	<!--HTML 문서의 제작자, 내용, 키워드 같은, 여러 정보를 검색엔진이나 브라우저에게 제공-->

	<title>Naver</title>
	<!--웹브라우저 탭에 표시되는 제목-->

	<link rel="stylesheet" href="./main.css" />
	<!--외부 문서를 가져와 연결할 때 사용 (CSS파일)-->

	<style>
		div {
			color: red;
		}
	</style>
	<!--html문서 안에 작성된 CSS-->

	<script src="./main.js"></script>
	<!--JS 파일 가져오는 경우-->

	<script>
		console.log("Hello world!");
	</script>
	<!--html문서 안에 작성된 JS-->
</head>
```

```html
<head>
	<style>
		span {
			color: red;
		} /*span 색을 빨간색으로 지정*/
	</style>
</head>
<body>
	<div>
		<!--특별한 의미 없는 구분을 위한 요소-->
		<h1>제목을 위한 헤딩</h1>
		<p>문장을 의미하는 요소(paragraph)</p>

		<img src="img/weather.jpg" alt="이미지 삽입요소" />

		<h2>제목2</h2>
		<h3>제목3</h3>
		<h4>제목4</h4>
		<h5>제목5</h5>
		<h6>제목6</h6>
		<!--숫자가 작을수록 더 중요한 제목-->

		<ul>
			<!--순서 필요없는 목록의 집합(unordered list)-->
			<li>목록</li>
			<li>목록2</li>
		</ul>

		<a href="https://www.naver.com" target="_blank">NAVER</a>
		<!--다른 페이지로 이동하는 하이퍼링크-->
		<p>
			<span>스타일 요소로 인해 이 문자는 빨갛게 바뀜</span>여기는 아직
			검정<br />여기는 브레이크 땜에 다음줄로 바뀜
		</p>
	</div>

	<input type="text" value="미리 입력된 값" /><!--데이터 입력-->
	<input type="text" placeholder="이름을 입력하세요!" />
	<!--placeholder는 사용자가 입력할 값의 힌트-->
	<input type="text" disabled />
	<!--비활성화-->

	<label>
		<!--인라인 요소, 라벨 가능 요소의 제목-->
		<input type="checkbox" /> Apple
	</label>
	<label>
		<!--인라인 요소, 라벨 가능 요소의 제목-->
		<input type="checkbox" checked /> Banana
	</label>

	<label>
		<input type="radio" name="fruits group" />
		Banana<!--체크 여부를 그룹에서 1개만 입력 받음-->
	</label>
	<label> <input type="radio" name="fruits group" /> Banana </label>

	<table>
		<!--테이블 요소-->
		<tr>
			<!--행(Row), table row-->
			<td>A</td>
			<td>B</td>
			<!--열(Column), table data-->
		</tr>
		<tr>
			<td>C</td>
			<td>D</td>
		</tr>
	</table>

	<!--Comments(주석)-->
</body>
```

## CSS 기본 문법

### 선택자 {속성: 값;}

-   선택자: 스타일을 적용할 대상 (Selector)
-   스타일(CSS)의 종료 (Property)
-   스타일(CSS)의 값(Value)
-   `속성: 값;`: `속성은 값이다`
-   {}: 스타일 범위의 시작과 끝

```css
div {
	color: red;
} /*글자색 빨강*/
div {
	color: red;
	margin: 20px;
} /*요소 외부 여백 20픽셀*/

/*설명 작성 (Comment, 주석)
CTRL + / 하면 그 줄 주석으로 변경
*/
```

### CSS 선언 방식

#### 내장 방식

```css
<style>
/* style내용(contents)으로 스타일 작성 방식 */
    div{
        color: red;
        margin: 20px;
    }
</style>
```

#### 링크 방식

```css
/* main.css 파일*/
div {
	color: red;
	margin: 20px;
}
```

```html
<!-- link로 외부 css문서를 가져와서 연결하는 방식 -->
<link rel="stylesheet" href="./css/main.css" />
```

#### 인라인 방식

```html
<!-- 요소의 style속성에 직접 스타일 작성하는 방식 -->
<div style="color:red; margin:20px;"></div>
```

#### @import 방식

```css
/* box.css 파일 */
.box {
	background-color: red;
	padding: 20px;
}
```

```css
/* main.css 파일*/
@import url("./box.css");
/* css의 @import 규칙으로 CSS 문서 안에서 또 다른 CSS문서 가져와 연결 */
div {
	color: red;
	margin: 20px;
}
```

```html
<!-- link로 외부 css문서를 가져와서 연결하는 방식 -->
<link rel="stylesheet" href="./css/main.css" />
```

### CSS 선택자

#### 기본

-   `*` : 전체 선택자 (Universal Selector)
    -   모든 요소를 선택

```css
* {
	color: red;
}
```

-   `ABC`: 태그 선택자 (Type Selector)
    -   태그 이름이 ABC인 요소 선택

```css
li {
	color: red;
}
```

-   `.ABC`: 클래스 선택자 (Class Selector)
    -   HTML class 속성의 값이 ABC인 요소 선택

```css
.orange {
	color: red;
}
```

```html
<li class="orange">orange</li>
```

-   `#ABC`: 아이디 선택자 (ID Selector)
    -   HTML id 속성의 값이 ABC인 요소 선택

```css
#orange {
	color: red;
}
```

```html
<li id="orange" class="green ">orange</li>
```

#### 복합

-   `ABCXYZ`: 일치 선택자 (Basic Combinator)
    -   선택자 ABC와 XYZ를 동시에 만족하는 요소 선택

```css
span.orange {
	color: red;
}
```

```html
<span class="orange">orange</span>
```

-   `ABC > XYZ`: 자식 선택자 (Child Combinator)
    -   선택자 ABC의 자식 요소 XYZ 선택

```css
ul > .orange {
	color: red;
}
```

```html
<ul>
	<li></li>
	<li class="orange">orange</li>
</ul>
```

-   `ABC XYZ`: 하위(후손) 선택자 (Descendant Combinator)
    -   선택자 ABC의 하위 요소 XYZ 선택

```css
div .orange {
	color: red;
}
```

```html
<div>
	<ul>
		<li></li>
		<li class="orange">orange</li>
		<!-- 해당 됨 -->
	</ul>
	<span class="orange">orange</span>
	<!-- 해당 됨 -->
</div>
<span class="orange">orange</span>
<!-- 해당 안됨 -->
```

-   `ABC + XYZ`: 인접 형제 선택자 (Adjacent Sibling Combinator)
    -   선택자 ABC의 다음 형제 요소 XYZ 하나 선택

```css
.orange + li {
	color: red;
}
```

```html
<ul>
	<li></li>
	<li class="orange">orange</li>
	<li>망고</li>
	<!-- 해당 됨 -->
</ul>
```

-   `ABC ~ XYZ`: 일반 형제 선택자 (General Sibling Combinator)
    -   선택자 ABC의 다음 형제 요소 XYZ 모두 선택

```css
.orange ~ li {
	color: red;
}
```

```html
<ul>
	<li></li>
	<li class="orange">orange</li>
	<li>망고</li>
	<!-- 해당 됨 -->
	<li>딸기</li>
	<!-- 해당 됨 -->
</ul>
```

#### 가상 클래스 (Pseudo-Classes)

-   `ABC:hover`: Hover
    -   선택자 ABC 요소에 마우스 커서가 올라가 있는 동안 선택

```css
a.hover {
	color: red;
}
```

```html
<a href="https://www.naver.com">Naver</a>
<!-- 마우스 커서 있을때 링크가 빨간색으로 바뀐다 -->
```

-   `ABC:active`: Active
    -   선택자 ABC 요소에 마우스를 클릭하고 있는 동안 선택

```css
a.active {
	color: red;
}
```

```html
<a href="https://www.naver.com">Naver</a>
<!-- 마우스로 링크 클릭하면 빨간색으로 바뀐다 -->
```

-   `ABC:focus`: Focus
    -   선택자 ABC 요소에 포커스 되면 선택

```css
input:focus {
	background-color: orange;
}
```

```html
<input type="text" />
<!-- 포커스 되면 주황색으로 바뀐다 -->
```

-   `ABC:first-child`: First Child
    -   선택자 ABC가 형제 요소 중 첫째라면

```css
.fruits span:first-child {
	background-color: red;
}
```

```html
<div class="fruits">
	<span>딸기</span
	><!--빨간색-->
	<span></span>
	<span></span>
</div>
```

-   `ABC:last-child`: Last Child
    -   선택자 ABC가 형제 요소 중 막내라면

```css
.fruits h3:last-child {
	background-color: red;
}
```

```html
<div class="fruits">
	<span>딸기</span>
	<span></span>
	<span></span>

	<h3>사과</h3>
	<!--빨간색-->
</div>
```

-   `ABC:nth-child(n)`: Nth Child
    -   선택자 ABC가 형제 요소 중 n번째라면

```css
.fruits *:nth-child(2) {
	color: red;
}
/* 짝수 경우 */
/* n은 0부터 시작 */
.fruits *:nth-child(2n) {
	color: orange;
}
/* 홀수 경우 */
.fruits *:nth-child(2n + 1) {
	color: yellow;
}
/* 2번째부터 쭉 */
.fruits *:nth-child(n + 2) {
	color: green;
}
```

```html
<div class="fruits">
	<span>딸기</span
	><!--노랑-->
	<span>수박</span
	><!--빨간색--><!--주황--><!--초록-->
	<span>오렌지</span
	><!--노랑--><!--초록-->
	<span>사과</span
	><!--주황--><!--초록-->
</div>
```

-   `ABC:not(XYZ)`: Negation
    -   선택자 XYZ가 아닌 ABC 요소 선택

```css
.fruits *:not(span) {
	color: red;
}
```

```html
<div class="fruits">
	<span>딸기</span>
	<span>수박</span>
	<div>오렌지</div>
	<!--선택-->
	<p>사과</p>
	<!--선택-->
</div>
```

#### 가상 요소 (Pseudo-Elements)

-   `ABC::before`: before
    -   선택자 ABC 요소의 내부 앞에 내용(content)을 삽입

```css
.box::before {
	content: "앞!";
}
```

```html
<div class="box">
	<!-- 이 위치에 "앞!" -->
	Content
</div>
```

-   `ABC::after`: after
    -   선택자 ABC 요소의 내부 뒤에 내용(content)을 삽입

```css
.box::before {
	content: "뒤!";
}
```

```html
<div class="box">
	Content
	<!-- 이 위치에 "뒤!" -->
</div>
```

#### 속성 (Attribute)

-   `[ABC]`: ATTR
    -   속성 ABC을 포함한 요소 선택

```css
[disabled] {
	color: red;
}
[type] {
	color: orange;
}
```

```html
<input type="text" value="HEROPY" />
<!--주황선택-->
<input type="password" value="1234" />
<!--주황선택-->
<input type="text" value="ABCD" disabled />
<!--선택-->
<!--주황선택-->
```

-   `[ABC = "XYZ"]`: ATTR = VALUE
    -   속성 ABC을 포함하고 값이 XYZ인 요소 선택

```css
[type="password"] {
	color: red;
}
```

```html
<input type="text" value="HEROPY" />
<input type="password" value="1234" /><!--선택-->
<input type="text" value="ABCD" disabled />
```

### 스타일 상속

```css
.animal {
	color: red;
}
```

```html
<div class="ecosystem">
	생태계
	<!-- animal class 안에 있는 모든 div는 빨간색이 된다 -->
	<div class="animal">
		동물
		<div class="tiger">호랑이</div>
		<div class="lion">사자</div>
		<div class="elephant">코끼리</div>
	</div>
	<div class="plant">식물</div>
</div>
```

#### 상속되는 CSS 속성들..

-   <u>모두 글자/문자 관련 속성들!</u>

    -   (모든 글자/문자 속성은 아님 주의!)

-   font-style: 글자 기울기
-   font-weight: 글자 두께
-   font-size: 글자 크기
-   line-height: 줄 높이
-   font-family: 폰트 (서체)
-   color: 글자 색상
-   text-align: 정렬
-   ...

### 선택자 우선순위

-   우선순위:
    -   같은 요소가 여러 선언의 대상이 된 경우, 어떤 선언의 CSS 속성을 우선 적용할지 결정하는 방법

1.  점수가 높은 선언이 우선함!
2.  점수가 같으면, 가장 마지막에 해석된 선언이 우선함!

```css
/* important: 9999999999999 
hello world will be red*/
div {
	color: red !important;
}
/* ID: 100 */
#color_yellow {
	color: yellow;
}
/* class: 10 */
.color_green {
	color: green;
}
/* tag: 1 */
div {
	color: blue;
}
/* entire: 0 */
* {
	color: darkblue;
}
/* 상속: X */
body {
	color: violet;
}
```

```html
<div id="color_yellow" class="color_green" style="color:orange;">
	<!-- inline: 1000 -->
	Hello world!
</div>
```

## CSS 속성

### 1. 박스 모델

#### width, height

-   요소의 가로/세로 <u>너비</u>
-   기본값: 요소에 이미 들어있는 속성의 값
-   auto: 브라우저가 너비를 계산
-   단위: px, em, vw 등 단위로 지정

#### [span](#span)

#### [div](#div)

#### max-width, max-height

-   요소가 커질 수 있는 <u>최대</u> 가로/세로 너비
-   none: 최대 너비 제한 없음
-   auto: 브라우저가 너비를 계산
-   단위: px, em, vw 등 단위로 지정

#### min-width, min-height

-   요소가 작아질 수 있는 <u>최소</u> 가로/세로 너비
-   0: 최소 너비 제한 없음
-   auto: 브라우저가 너비를 계산
-   단위: px, em, vw 등 단위로 지정

-   단위
    -   px: 픽셀
    -   %: 상대적 백분율
    -   em: 요소의 글꼴 크기
    -   rem: 루트 요소 (html)의 글꼴 크기
    -   vw: 뷰포트 가로 너비의 백분율
    -   vh: 뷰포트 세로 너비의 백분율

#### margin

-   요소의 <u>외부</u> 여백(공간)을 지정하는 <u>단축 속성</u>
-   음수 사용 가능
-   0: 외부 여백 없음
-   auto: 브라우저가 여백을 계산
    -   가로(세로) 너비가 있는 요소의 <u>가운데 정렬</u>에 활용해요
-   단위: px, em, vw등 단위로 지정
-   %: 부모 요소의 <u>가로 너미</u>에 대한 비율로 지정

```
- margin: 0px; margin: 10px;
    - 상하좌우 전부 적용
- margin: 10px 20px;
    - 상하 10, 좌우 20
- margin: 10px 20px 30px;
    - 상 10, 좌우 20, 하 30
- margin: 10px 20px 30px 40px; (시계방향)
    - 상 10, 우 20, 하 30, 좌 40
```

##### margin-방향

-   요소의 외부 여백(공간)을 지정하는 기타 <u>개별 속성들</u>
-   margin-top, margin-bottom, margin-left, margin-right

#### padding

-   요소의 <u>내부 여백</u>(공간)을 지정하는 <u>단축 속성</u>
-   요소의 크기가 커져요
-   0: 내부 여백 없음
-   단위: px, em, vw 등 단위로 지정
-   %: 부모 요소의 <u>가로 너비</u>에 대한 비율로 지정

```
- padding: 0px; margin: 10px;
    - 상하좌우 전부 적용
- padding: 10px 20px;
    - 상하 10, 좌우 20
- padding: 10px 20px 30px;
    - 상 10, 좌우 20, 하 30
- padding: 10px 20px 30px 40px; (시계방향)
    - 상 10, 우 20, 하 30, 좌 40
```

##### padding-방향

-   요소의 내부 여백(공간)을 지정하는 기타 <u>개별 속성들</u>
-   padding-top, padding-bottom, padding-left, padding-right

#### border

-   요소의 <u>테두리 선</u>을 지정하는 <u>단축 속성</u>
-   요소의 크기가 커져요
-   border: width style color;
-   선-두께: border-width
-   선-종류: border-style
-   선-색상: border-color

```css
border: medium none black;

border: 10px solid black;
```

##### border-width

-   요소 테두리 선의 두께
-   medium: 중간 두께
-   thin: 얇은 두께
-   thick: 두꺼운 두께
-   단위: px, em, % 등 단위로 지정

##### border-style

-   요소 테두리 선의 종류
-   none: 없음
-   solid: 실선 (일반 선)
-   dotted: 점선
-   dashed: 파선
-   double: 두줄선
-   groove: 홈이 파여있는 모양
-   ridge: 솟은 모양(groove의 반대)
-   inset: 요소 전체가 들어간 모양
-   outset: 요소 전체가 나온 모양

##### border-color

-   요소 테두리 선의 <u>색상을 지정하는 단축 속성</u>
-   black: 검정색
-   색상: 선의 색상
-   transparent: 투명
-   색상 표현:
    -   HEX red, tomato, royalblue
    -   색상코드 RGB #000, #FFFFFF
    -   RGBA: 삼원색 rgb(255,255,255)
        -   빛의 삼원색+투명도 rgba(0,0,0,0.5)
    -   ...

##### border-방향; border-방향-속성

-   border-top: width style color;
-   border-left-width: width;
-   border-bottom-style: style;
-   ...

##### border-radius

-   요소의 모서리를 <u>둥글게 깎음</u>
-   0: 둥글게 없음
-   단위: px, em, vw 등 단위로 지정
-   가장 왼쪽위에 위치된 모서리부터 시계방향

#### box-sizing

-   요소의 <u>크기 계산 기준</u>을 지정
-   content-box: 요소의 내용 (content)으로 크기 계산
-   border-box: 요소의 내용+padding+border로 크기 계산

#### overflow

-   요소의 크기 이상으로 <u>내용이 넘쳤을 때, 보여짐을 제어</u>하는 <u>단축 속성</u>
-   visible: 넘친 내용을 그대로 보여줌
-   hidden: 넘친 내용을 잘라냄
-   scroll: 넘친 내영을 잘라냄, 스크롤바 생성
-   auto: 넘친 내용이 있는 경우에만 잘라내고 스크롤바 생성

#### display

-   요소의 화면 <u>출력(보여짐) 특정</u>
-   whether an element is treated as a <u>block or inline box</u> and the layout used for its children, such as <u>flow layout, grid, or flex</u>
-   요소에 이미 지정되어 있는 값
    -   block: 상자(레이아웃) 요소
    -   inline: 글자 요소
    -   inline-block: 글자+상자 요소
-   따로 지정해서 사용하는 값
    -   flex: 플렉스 박스 (1차원 레이아웃)
    -   grid: 그리드 (2차원 레이아웃)
    -   none: 보여짐 특성 없음, 화면에서 사라짐
-   기타
    -   table, table-row, table-cell, ...

#### opacity

-   요소 투명도
-   1: 불투명
-   0-1: 0부터 1사이의 소수점 숫자

### 2. 글꼴, 문자

#### 글꼴

##### font-style

-   글자의 기울기
-   normal: 없음
-   italic: 이텔릭체
-   oblique: 기울어진 글자

##### font-weight

-   글자의 두께 (가중치)
-   normal, 400: 기본
-   bold, 700: 두껍게
-   bolder: 상위 (부모) 요소보다 더 두껍게
-   lighter: 상위 (부모) 요소보다 더 얇게
-   100-900: 100단위의 숫자 9개, normal과 bold 이외 두께

##### font-size

-   글자의 크기
-   16px: 기본
-   단위:px, em, rem등 단위로 지정
-   %: 부모 요소의 폰트 크기에 대한 비율
-   smaller: 상위 (부모) 요소보다 작은 크기
-   larger: 상위 (부모) 요소보다 큰 크기
-   xx-small - xx-large: 가장 작은 크기에서 가장 큰 크기; 7단계로 크기 지정

##### line-height

-   한 줄의 높이, 행간과 유사
-   normal: 기본
-   숫자: 요소의 글꼴 크기의 배수로 지정
-   단위: px, em, rem등의 단위로 지정
-   %: 요소의 글꼴 크기의 비율로 지정

```css
font-size: 16px;
line-height: 32px;
/* line-height:2;
line-height: 200%; */
```

##### font-family: 글꼴1, "글꼴2", ... 글꼴계열;

-   글꼴(서체) 지정
-   계열 필수 작성

```
serif, sans-serif, monospace, cursive, fantasy
```

#### 문자

##### color

-   글자의 색상
-   rgb(0,0,0): 검정
-   색상: 기타

##### text-align

-   문자의 정렬 방식
-   left, right, center
-   justify: 양쪽

##### text-decoration

-   문자의 장식(선)
-   none: 없음
-   underline: 밑줄
-   overline: 윗줄
-   line-through: 중앙선

##### text-indent

-   문자 첫줄의 들여쓰기
-   음수 사용 가능
    -   반대는 내어쓰기 (outdent)
-   0: 없음
-   단위: px, em, rem 등 단위로 지정

### 3. 배경

#### background-color

-   요소의 배경 색상
-   transparent: 투명
-   색상: 기타 색상

#### background-image

-   요소의 배경 이미지 삽입
-   none: 없음
-   url("경로"): 이미지 경로

#### background-repeat

-   요소의 배경 이미지 반복
-   repeat: 수직, 수평 반복
-   repeat-x: 수평 반복
-   repeat-y: 수직 반복
-   no-repeat: 반복 없음

#### background-position

-   요소의 배경 이미지 위치
-   0% 0%: 0~100% 사이
-   방향: top, bottom, left, right, center
-   단위: px, em, rem등 단위로 지정

#### background-size

-   요소의 배경 이미지 크기
-   auto: 실제 크기
-   단위: px, em, rem 등 단위로 지정
-   cover: 비율로 유지, 요소의 더 넓은 너비에 맞춤
-   contain: 비울을 유지, 요소의 더 짧은 넙에 맞춤

#### background-attachment

-   요소의 배경 이미지 스크롤 특성
-   scroll: 요소를 따라서 같이 스크롤
-   fixed: 뷰포트에 고정, 스크롤 X
-   local: 요소 스크롤 시 이미지가 같이 스크롤

### 4. 배치

#### position

-   요소의 위치 지정 기준
-   position과 같이 사용하는 CSS 속성들! 모두 음수를 사용할 수 있어요
    -   top, bottom, left, right, z-index
-   static: 기준 없음
-   relative: 요소 자신을 기준
-   absolute: 위치 상 부모 요소를 기준
    -   부모 위치 중요
    -   부모가 relative이어야 그 부모 기준을 따른다
-   fixed: 뷰포트(브라우저)를 기준
-   sticky: 스크롤 영역 기준

#### top, bottom, left, right

-   요소의 각 방향별 거리 지정
-   auto: 브라우저가 계산
-   단위: px, em, rem 등 단위로 지정

#### 요소 쌓임 순서 (Stack order)

-   어떤 여소가 사용자와 더 가깝게 있는지 (위에 쌓이는지) 결정

1. 요소에 position 속성의 값이 있는 경우 위에 쌓임 (기본값 static 제외)
2. 1번 조건이 같은 경우, z-index 속성의 숫자 값이 높을 수록 위에 쌓임
3. 1번과 2번 조건까지 같은 경우, HTML의 다음 구조일 수록 위에 쌓임

#### z-index

-   요소의 쌓임 정도를 지정
-   auto: 부모 요소와 동일한 쌓임 정도
-   숫자: 숫자 높을 수록 위에 쌓임

#### 요소의 display가 변경됨

-   position 속성의 값으로 <u>absolute, fixed</u>가 지정된 요소는, display 속성이 block으로 변경됨

### 5. 플렉스 (정렬)

#### Flex Container Flex Item

-   In order to create a flex layout, we first need to set up a flex container. Any element can be set as a flex container using `display:flex` declaration
-   The elements within a flex container are referred to as flex items. The available space within the container can be distributed efficiently among the flex items

#### flex-direction: row;

-   main axis: refers to the primary axis along which the flex item are arranged within the flex container
    -   either horizontal or vertical direciton
    -   depends upon the value of the flex-direction property

#### display

-   Flex container의 화면 출력 (보여짐) 특징
-   flex: 블록 요소와 같이 Flex Container 정의
-   inline-flex: 인라인 요소와 같이 Flex Container 정의

#### flex-direction

-   주 축을 설정
-   row: 행 축 (좌->우)
-   row-reverse: 행 축 (우->좌)
-   column: 열 축 (위->아래)
-   column-reverse: 열축 (아래->위)

#### flex-wrap

-   Flex items 묶음 (줄 바꿈) 여부
-   nowrap: 묶음(줄 바꿈 없음)
-   wrap: 여러 줄로 묶음
-   wrap-reverse: wrap의 반대 방향으로 묶음

#### justify-content

-   flex-start: flex items를 시작점으로 정렬
-   flex-end: flex items를 끝점으로 정렬
-   center: flex items를 가운데 정렬
-   space-between: 각 flex item 사이를 균등하게 정렬
-   space-around: 각 flex item의 외부 여백을 균등하게 정렬

#### align-content

-   교차 축의 여러 줄 정렬 방법
-   controls the alignment of flex lines when there is extra space in the cross-axis
-   stretch: Flex items를 시작점으로 정렬
-   flex-start: flex items를 시작점으로 정렬
-   flex-end: flex items를 끝점으로 정렬
-   center: flex items를 가운데 정렬
-   space-between: 각 flex item 사이를 균등하게 정렬
-   space-around: 각 flex item의 외부 여백을 균등하게 정렬

#### align-items

-   교차 축의 한 줄 정렬 방법
-   distributes the available space between the flex items along the cross axis
-   space distributed vertically for flex-direction:row and horizontally for flex-direction: column

-   stretch: flex items를 교차 축으로 늘림
-   flex-start: flex items를 각 줄의 시작점으로 정렬
-   flex-end: flex items를 각 줄의 끝점으로 정렬
-   center: flex items를 각 줄의 가운데 정렬
-   baseline: flex items를 각 줄의 문자 기준선에 정렬

#### order

-   flex item 의 순서
-   0: 순서 없음
-   숫자: 숫자가 작을 수록 먼저

#### flex-grow

-   flex item의 증가 너비 비율
-   0: 증가 비율 없음
-   숫자: 증가 비율
-   flex items grow proportionally to take the available space within the second flex container
-   flex-grow:2 makes flex item grow twice as much as the flex-grow:1 when there's extra space in the flex container

#### flex-shrink

-   flex item의 감소 너비 비율
-   1: flex container 너비에 따라 감소 비율 적용
-   숫자: 감소 비율

#### flex-basis

-   flex item의 공간 배분 전 기본 너비
-   auto: 요소의 content 너비
-   단위: px, em, rem 등 단위로 지정
-   alternative to the width and height of the flex items

### 6. 전환

### 7. 변환

### 8. 띄움

### 9. 애니메이션

### 10. 그리드

### 11. 다단

### 12. 필터

## JS 선행 학습

### 표기법

#### dash-case (kebab-case)

-   the-quick-brown-fox-jumps-over-the-lazy-dog

#### snake_case

-   the_quick_brown_fox_jumps_over_the_lazy_dog

#### camelCase

-   theQuickBrownFoxJumpsOverTheLazyDog

#### PascalCase

-   The QuickBrownFoxJumpsOverTheLazyDog

### Zero-based Numbering

-   0기반 번호 매기기!
-   특수한 경우를 제외하고 0부터 숫자를 시작합니다

```javascript
let fruits = ["Apple", "Banana", "Cherry"];

console.log(fruits[0]); //Apple
console.log(fruits[1]); //Banana
console.log(fruits[2]); //Cherry

console.log(new Date("2021-01-30").getDay()); // 6, 토요일
console.log(new Date("2021-01-31").getDay()); // 0, 일요일
console.log(new Date("2021-02-01").getDay()); // 1, 월요일
```

### 주석

```js
// 한줄 메모
/*한줄 메모*/

/**
 * 여러
 * 줄
 * 메모1
 * 메모2
 * 메모3
 * /

```

### 데이터 종류 (자료형)

-   String
-   Number
-   Boolean
-   Undefined
-   Undefined
-   Null Object
-   Array

```js
let a = 123;
const n=obj.name;
	document.querySelector('.data-abc')
	{name.'Heropy', age:85}

	function mount(params){
		return this;
	}
```

```js
// String(문자 데이터)
// 따옴표를 사용합니다.
let myName = "HEROPY";
let email = "thesecon@gmail.com";
let hello = `Hello ${myName}?!`;
console.log(myName); // HEROPY
console.log(email); // thesecon@gmail.com
console.log(hello); // Hello HEROPY?!

// Number(숫자 데이터)
// 정수 및 부동소수점숫자를나타냅니다.
let number = 123;
let opacity = 1.57;
console.log(number); // 123
console.log(opacity); // 1.57

// Boolean(불린 데이터)
// true, false 두 가지 값밖에 없는 논리 데이터입니다.
let checked = true;
let isShow = false;
console.log(checked); // true
console.log(isShow); // false

// Undefined
// 값이 할당되지 않은 상태를 나타냅니다.
let undef;
let obj = { abc: 123 };
console.log(undef); // undefined
console.log(obj.abc); // 123
console.log(obj.xyz); // undefined

// Null
// 어떤 값이 의도적으로비어있음을 의미합니다.
let empty = null;
console.log(empty); // null

// Object(객체 데이터)
// 여러 데이터를 Key:Value 형태로 저장합니다. { }
let user = {
	// Key: Value,
	name: "HEROPY",
	age: 85,
	isValid: true,
};
console.log(user.name); // HEROPY
console.log(user.age); // 85
console.log(user.isValid); // true

// Array(배열 데이터)
// 여러 데이터를 순차적으로저장합니다. [ ]
let fruits = ["Apple", "Banana", "Cherry"];
console.log(fruits[0]); // 'Apple'
console.log(fruits[1]); // 'Banana'
console.log(fruits[2]);
//'Chery'
```

### 변수

-   데이터를 저장하고 참조 (사용)하는 데이터의 이름 var, let, const

```js
// 재사용이 가능!
// 변수 선언!
let a = 2;
let b = 5;
console.log(a + b); // 7
console.log(a - b); //-3
console.log(a * b); // 10
console.log(a / b); // 0.4

// 값(데이터)의재할당 가능!
let a = 12;
console.log(a); // 12
a = 999;
console.log(a); // 999

// 값(데이터)의재할당 불가!
const a = 12;
console.log(a); // 12
a = 999;
console.log(a); // TypeError: Assignment to constant variable.
```

### 예약어

-   특별한 의미를 가지고 있어, 변수나 함수 이름 등으로 사용할 수 없는 단어
-   Reserved Word

```js
let this = 'Hello!'; // SyntaxError
let if = 123; // SyntaxError
 let break = true; // SyntaxError

```

### 함수

-   특정 동작(기능)을 수행하는 일부 코드의 집합(부분)function

```js
// 함수 선언
function helloFunc() {
	// 실행 코드
	console.log(1234);
}
// 함수 호출
helloFunc(); // 1234

function returnFunc() {
	return 123;
}
let a = returnFunc();
console.log(a); // 123


// 함수 선언!
function sum(a, b) { // a와 b는 매개변수
(Parameters) return a + b;
}
// 재사용!
let a = sum(1, 2); // 1과2는인수(Arguments)
let b = sum(7, 12);
let c = sum(2, 4);
console.log(a, b, c); // 3, 19, 6


 // 기명(이름이 있는) 함수
// 함수 선언!
function hello() {
	console.log('Hello~');
}
 // 익명(이름이 없는) 함수
// 함수 표현!
let world = function () {
	console.log('World~');
}
 // 함수
호출!
hello(); // Hello~
world(); // World~



// 객체 데이터
const heropy = {
	name: 'HEROPY',
	age: 85,
// 메소드(Method)
getName: function () {
	return this.name;
}
};
const hisName = heropy.getName();
console.log(hisName); // HEROPY
// 혹은
console.log(heropy.getName()); // HEROPY
```

### 조건문

-   조건의 결과 (truth, false)에 따라 다른 코드를 실행하는 구문
-   if, else

```js
let isShow = true;
let checked = false;
if (isShow) {
	console.log("Show!"); // Show!
}
if (checked) {
	console.log("Checked!");
}

let isShow = true;
if (isShow) {
	console.log("Show!");
} else {
	console.log("Hide?");
}
```

### DOM API

-   Document Object Model, Application Programming Interface

```html
<!DOCTYPE html>
<html lang="ko">
	<head>
		<meta charset="UTF-8" />
		<meta
			name="viewport"
			content="width=device-width, initial- 
scale=1.0"
		/>
		<title>Document</title>
		<script src="./main.js"></script>
	</head>
</html>
```

```html
<!DOCTYPE html>
<html lang="ko">
	<head>
		<meta charset="UTF-8" />
		<meta
			name="viewport"
			content="width=device-width, initial-
scale=1.0"
		/>
		<title>Document</title>
	</head>
	<body>
		<div class="box">Box!!</div>
		<script src="./main.js"></script>
	</body>
</html>
```

```html
<!DOCTYPE html>
<html lang="ko">
	<head>
		<meta charset="UTF-8" />
		<meta
			name="viewport"
			content="width=device-width, initial- 
scale=1.0"
		/>
		<title>Document</title>
		<script defer src="./main.js"></script>
	</head>
	<body>
		<div class="box">Box!!</div>
	</body>
</html>
```

```js
// HTML 요소(Element) 1개 검색/찾기
const boxEl = document.querySelector(".box");

// HTML 요소에 적용할 수 있는 메소드
!boxEl.addEventListener();

// 인수(Arguments)를 추가 가능!
boxEl.addEventListener(1, 2);

// 1 - 이벤트(Event, 상황)
boxEl.addEventListener("click", 2);

// 2 - 핸들러(Handler, 실행할 함수)
boxEl.addEventListener("click", function () {
	console.log("Click~!");
});

// HTML 요소(Element) 검색/찾기
const boxEl = document.querySelector(".box");

// 요소의 클래스 정보 객체 활용!
boxEl.classList.add("active");
let isContains = boxEl.classList.contains("active");
console.log(isContains); // true

boxEl.classList.remove("active");
isContains = boxEl.classList.contains("active");
console.log(isContains); // false

// HTML 요소(Element) 모두 검색/찾기
const boxEls = document.querySelectorAll(".box");
console.log(boxEls);

// 찾은 요소들 반복해서 함수 실행!
// 익명 함수를 인수로 추가!
boxEls.forEach(function () {});

// 첫 번째 매개변수(boxEl): 반복 중인 요소.
// 두 번째 매개변수(index): 반복 중인 번호
boxEls.forEach(function (boxEl, index) {});

// 출력!
boxEls.forEach(function (boxEl, index) {
	boxEl.classList.add(`order-${index + 1}`);
	console.log(index, boxEl);
	251;
});

const boxEl = document.querySelector(".box");

// Getter, 값을 얻는 용도
console.log(boxEl.textContent); // Box!!

// Setter, 값을 지정하는 용도
boxEl.textContent = "HEROPY?!";
console.log(boxEl.textContent); // HEROPY?!
```

### 메소드 체이닝

```js
const a = 'Hello~';

 // split: 문자를 인수 기준으로 쪼개서 배열로 반환.
 // reverse: 배열을 뒤집기.
 // join: 배열을 인수 기준으로 문자로 병합해 반환.
 const b = a.split('').reverse().join(''); // 메소드 체이닝
...
 console.log(a); // Hello~
 console.log(b); // ~olleH


```
